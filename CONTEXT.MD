# ğŸ—ï¸ Guide Complet : Architecture Multi-Tenant SaaS avec NestJS

## ğŸ“‹ Vue d'ensemble

Cette application **Helpdeskly** implÃ©mente une architecture **multi-tenant** avec le pattern **"Database-per-Tenant"** utilisant **NestJS**, **Prisma**, et **PostgreSQL**. Chaque client (tenant) possÃ¨de sa propre base de donnÃ©es dÃ©diÃ©e, garantissant l'isolation complÃ¨te des donnÃ©es.

---

## ğŸ¯ Concepts ClÃ©s

### **Multi-Tenancy Pattern : Database-per-Tenant**

- **1 base de donnÃ©es de contrÃ´le** : GÃ¨re les mÃ©tadonnÃ©es des tenants
- **N bases de donnÃ©es tenant** : Une base dÃ©diÃ©e par client
- **Isolation totale** : Aucun risque de fuite de donnÃ©es entre clients
- **ScalabilitÃ©** : Chaque tenant peut Ã©voluer indÃ©pendamment

### **Architecture en Microservices**

```
Control API (Port 3001) â”€â”€â”€ Gestion des tenants, provisioning
    â”‚
    â””â”€â”€ Base de contrÃ´le (metadata)

App API (Port 3000) â”€â”€â”€â”€â”€â”€â”€ Application mÃ©tier multi-tenant
    â”‚
    â””â”€â”€ Bases tenant individuelles
```

---

## ğŸ—‚ï¸ Structure du Projet

```
helpdeskly/
â”œâ”€â”€ ğŸ“ apps/
â”‚   â”œâ”€â”€ ğŸ“ control-api/          # API de gestion des tenants
â”‚   â””â”€â”€ ğŸ“ app-api/              # API applicative multi-tenant
â”œâ”€â”€ ğŸ“ prisma/
â”‚   â”œâ”€â”€ ğŸ“ control/              # SchÃ©ma base de contrÃ´le
â”‚   â””â”€â”€ ğŸ“ tenant/               # SchÃ©ma base tenant
â”œâ”€â”€ ğŸ“ pgadmin/                  # Configuration PgAdmin
â”œâ”€â”€ ğŸ³ docker-compose.yml       # Infrastructure complÃ¨te
â””â”€â”€ ğŸ“„ package.json             # Workspace monorepo
```

---

## ğŸ® Control API - Gestion des Tenants

### **RÃ´le**

GÃ¨re le cycle de vie des tenants : crÃ©ation, activation, dÃ©sactivation, provisioning des bases de donnÃ©es.

### **Base de donnÃ©es de contrÃ´le**

```prisma
// prisma/control/schema.prisma
model Tenant {
  id        String       @id @default(cuid())
  name      String       // Nom commercial du client
  slug      String       @unique // Identifiant unique (ex: "acme-corp")
  dbUrl     String       // URL de connexion Ã  la DB tenant
  status    TenantStatus @default(ACTIVE)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
}

enum TenantStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}
```

### **Services ClÃ©s**

#### **1. TenantService**

```typescript
// apps/control-api/src/tenants/tenants.service.ts
@Injectable()
export class TenantsService {
  // CrÃ©ation d'un nouveau tenant
  async create(createTenantDto: CreateTenantDto) {
    // 1. Validation du slug (unique, format)
    // 2. CrÃ©ation de la DB dÃ©diÃ©e
    // 3. ExÃ©cution des migrations
    // 4. Enregistrement en base de contrÃ´le
  }

  // Provisioning asynchrone via BullMQ
  async provision(tenantId: string) {
    // Job queue pour crÃ©ation DB + migrations
  }
}
```

#### **2. ProvisioningProcessor**

```typescript
// apps/control-api/src/provisioning/provisioning.processor.ts
@Processor("tenant-provisioning")
export class ProvisioningProcessor {
  @Process("create-database")
  async createDatabase(job: Job) {
    // 1. CrÃ©ation physique de la DB PostgreSQL
    // 2. GÃ©nÃ©ration URL de connexion
    // 3. ExÃ©cution migrations Prisma
    // 4. Validation de la structure
  }
}
```

---

## ğŸš€ App API - Application Multi-Tenant

### **RÃ´le**

Sert l'application mÃ©tier avec rÃ©solution automatique du tenant et connexion Ã  la bonne base de donnÃ©es.

### **Base de donnÃ©es tenant**

```prisma
// prisma/tenant/schema.prisma
model Ticket {
  id           String        @id @default(cuid())
  title        String
  description  String
  status       TicketStatus  @default(OPEN)
  priority     TicketPriority @default(MEDIUM)
  authorId     String
  assignedToId String?

  // Relations
  author       User          @relation("TicketAuthor", fields: [authorId], references: [id])
  assignedTo   User?         @relation("TicketAssignee", fields: [assignedToId], references: [id])
  comments     Comment[]

  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
}

model User {
  id              String    @id @default(cuid())
  email           String    @unique
  name            String
  role            UserRole

  // Relations inverses
  tickets         Ticket[]  @relation("TicketAuthor")
  assignedTickets Ticket[]  @relation("TicketAssignee")
  comments        Comment[]
}

model Comment {
  id       String   @id @default(cuid())
  body     String
  ticketId String
  authorId String

  // Relations
  ticket   Ticket   @relation(fields: [ticketId], references: [id])
  author   User     @relation(fields: [authorId], references: [id])

  createdAt DateTime @default(now())
}
```

### **RÃ©solution du Tenant**

#### **1. TenantContextMiddleware**

```typescript
// apps/app-api/src/middleware/tenant-context.middleware.ts
@Injectable()
export class TenantContextMiddleware implements NestMiddleware {
  async use(req: Request, _res: Response, next: NextFunction) {
    try {
      // 1. Extraction du slug depuis header ou sous-domaine
      const slug = req.headers["x-tenant-slug"] || req.hostname.split(".")[0];

      // 2. Validation sÃ©curisÃ©e du slug
      const validatedSlug = this.validateTenantSlug(slug);

      // 3. Recherche du tenant en base de contrÃ´le
      const tenant = await this.controlPrisma.tenant.findUnique({
        where: { slug: validatedSlug },
      });

      // 4. VÃ©rification statut actif
      if (!tenant || tenant.status !== "ACTIVE") {
        throw new ForbiddenException("Tenant not found or inactive");
      }

      // 5. Injection du contexte tenant dans la requÃªte
      req.tenant = {
        id: tenant.id,
        slug: tenant.slug,
        prisma: await this.tenantFactory.getClient(tenant.id, tenant.dbUrl),
      };

      next();
    } catch (error) {
      next(error);
    }
  }
}
```

#### **2. TenantClientFactory**

```typescript
// apps/app-api/src/prisma/tenant-prisma.factory.ts
@Injectable()
export class TenantClientFactory implements OnModuleDestroy {
  private readonly cache = new Map<string, CachedTenantClient>();
  private readonly maxConnectionsPerTenant = 5;
  private readonly maxTotalConnections = 100;

  async getClient(tenantId: string, dbUrl: string): Promise<PrismaClient> {
    // 1. VÃ©rification des limites de connexion
    this.checkConnectionLimits(tenantId);

    // 2. Retour du client en cache si disponible
    const cached = this.cache.get(tenantId);
    if (cached) {
      cached.lastAccessed = Date.now();
      return cached.client;
    }

    // 3. CrÃ©ation nouveau client avec gestion d'erreurs
    return this.createNewClient(tenantId, dbUrl);
  }

  private async createNewClient(
    tenantId: string,
    dbUrl: string
  ): Promise<PrismaClient> {
    const client = new PrismaClient({
      datasources: { db: { url: dbUrl } },
      log: ["error", "warn"],
    });

    // Test de connexion
    await client.$connect();

    // Mise en cache avec mÃ©tadonnÃ©es
    this.cache.set(tenantId, {
      client,
      lastAccessed: Date.now(),
      connectionCount: 1,
    });

    return client;
  }
}
```

### **Services MÃ©tier**

#### **TicketsService**

```typescript
// apps/app-api/src/ticket/ticket.service.ts
@Injectable()
export class TicketsService {
  list(req: Request) {
    // Utilisation automatique de la DB tenant rÃ©solue
    return req.tenant!.prisma.ticket.findMany({
      include: {
        author: true,
        assignedTo: true,
        comments: { include: { author: true } },
      },
    });
  }

  create(req: Request, dto: CreateTicketDto) {
    return req.tenant!.prisma.ticket.create({
      data: {
        title: dto.title,
        description: dto.description,
        authorId: dto.authorId,
        assignedToId: dto.assignedToId,
        priority: dto.priority || "MEDIUM",
        status: dto.status || "OPEN",
      },
      include: {
        author: true,
        assignedTo: true,
      },
    });
  }
}
```

---

## ğŸ”§ Configuration et Infrastructure

### **Docker Compose**

```yaml
# docker-compose.yml
services:
  postgres:
    image: postgres:16
    ports: ["5432:5432"]
    environment:
      POSTGRES_USER: root
      POSTGRES_PASSWORD: root

  pgbouncer:
    image: edoburu/pgbouncer
    ports: ["6432:6432"]
    # Pool de connexions pour optimiser les performances

  redis:
    image: redis:7
    ports: ["6379:6379"]
    # Queue BullMQ pour provisioning asynchrone

  pgadmin:
    image: dpage/pgadmin4:8
    ports: ["5050:80"]
    # Interface d'administration des bases
```

### **Workspace MonoRepo**

```json
// package.json
{
  "workspaces": ["apps/*", "libs/*"],
  "scripts": {
    "dev:control": "pnpm --filter control-api start:dev",
    "dev:app": "pnpm --filter app-api start:dev",
    "dev": "concurrently \"pnpm dev:control\" \"pnpm dev:app\""
  }
}
```

---

## ğŸ›¡ï¸ SÃ©curitÃ© et Validation

### **Validation des Slugs**

```typescript
private validateTenantSlug(slug: string): string {
  if (!slug || typeof slug !== 'string') {
    throw new ForbiddenException('Tenant slug is required');
  }

  // Format strict : lettres minuscules, chiffres, tirets
  if (!/^[a-z0-9-]+$/.test(slug) || slug.length > 50) {
    throw new ForbiddenException('Invalid tenant slug format');
  }

  // Blacklist des slugs rÃ©servÃ©s
  const reserved = ['api', 'www', 'admin', 'app'];
  if (reserved.includes(slug)) {
    throw new ForbiddenException('Reserved slug');
  }

  return slug.toLowerCase();
}
```

### **Exceptions PersonnalisÃ©es**

```typescript
// apps/app-api/src/common/exceptions/tenant.exceptions.ts
export class TenantNotFoundException extends HttpException {
  constructor() {
    super("Tenant not found", HttpStatus.NOT_FOUND);
  }
}

export class TenantInactiveException extends HttpException {
  constructor() {
    super("Tenant is inactive", HttpStatus.FORBIDDEN);
  }
}

export class TenantConnectionLimitException extends HttpException {
  constructor() {
    super("Connection limit reached", HttpStatus.TOO_MANY_REQUESTS);
  }
}
```

---

## ğŸ”„ Flux de DonnÃ©es Complet

### **1. CrÃ©ation d'un Tenant**

```
Client â†’ Control API â†’ TenantService â†’ ProvisioningQueue
                                    â†“
PostgreSQL â† Migrations â† Database Creation â† BullMQ Job
    â†“
Tenant DB crÃ©Ã©e â†’ Enregistrement en base de contrÃ´le
```

### **2. RequÃªte Application**

```
Client Request â†’ App API â†’ TenantMiddleware
                              â†“
                    Slug Validation â†’ Control DB Query
                              â†“
                    Tenant Found â†’ Factory.getClient()
                              â†“
                    Tenant DB Connection â†’ Business Logic
                              â†“
                    Response â† Data Processing â† Tenant Data
```

---

## ğŸš€ Patterns de DÃ©veloppement

### **DTOs avec Validation**

```typescript
// create-ticket.dto.ts
export class CreateTicketDto {
  @IsString()
  @MaxLength(200)
  title!: string;

  @IsString()
  description!: string;

  @IsString()
  @IsUUID()
  authorId!: string;

  @IsOptional()
  @IsEnum(TicketPriority)
  priority?: TicketPriority;
}
```

### **Type Safety avec Prisma**

```typescript
// Types automatiquement gÃ©nÃ©rÃ©s
type TicketWithRelations = Prisma.TicketGetPayload<{
  include: {
    author: true;
    assignedTo: true;
    comments: { include: { author: true } };
  };
}>;
```

---

## ğŸ“Š Monitoring et MÃ©triques

### **Connection Pool Monitoring**

```typescript
interface TenantMetrics {
  totalConnections: number;
  activeClients: number;
  connectionsByTenant: Map<string, number>;
}

getMetrics(): TenantMetrics {
  return {
    totalConnections: this.totalConnections,
    activeClients: this.cache.size,
    connectionsByTenant: new Map(
      Array.from(this.cache.entries()).map(([id, cached]) =>
        [id, cached.connectionCount]
      )
    )
  };
}
```

### **Health Checks**

```typescript
private async performHealthChecks(): void {
  for (const [tenantId, cached] of this.cache.entries()) {
    try {
      await cached.client.$queryRaw`SELECT 1`;
    } catch (error) {
      this.logger.warn(`Health check failed for tenant ${tenantId}`);
      await this.removeClient(tenantId);
    }
  }
}
```

---

## ğŸ¯ Points ClÃ©s pour RÃ©plication

### **1. Isolation Totale**

- Chaque tenant = base de donnÃ©es sÃ©parÃ©e
- Aucun partage de donnÃ©es possible
- Migrations indÃ©pendantes par tenant

### **2. RÃ©solution Dynamique**

- Middleware intercepte toutes les requÃªtes
- Slug du tenant extrait depuis header/sous-domaine
- Client Prisma rÃ©solu dynamiquement

### **3. Performance**

- Pool de connexions par tenant avec limites
- Cache en mÃ©moire avec expiration
- Health checks automatiques

### **4. ScalabilitÃ©**

- Provisioning asynchrone via queues
- Connection pooling avec PgBouncer
- Monitoring des mÃ©triques de performance

### **5. SÃ©curitÃ©**

- Validation stricte des slugs
- Blacklist des mots rÃ©servÃ©s
- Gestion d'erreurs robuste

---

## ğŸš€ Commandes de DÃ©marrage

```bash
# Infrastructure
docker compose up -d

# Bases de donnÃ©es
pnpm exec prisma migrate dev --schema=prisma/control/schema.prisma
pnpm exec prisma generate --schema=prisma/control/schema.prisma
pnpm exec prisma generate --schema=prisma/tenant/schema.prisma

# Applications
pnpm dev:control  # Port 3001
pnpm dev:app      # Port 3000
```

---

## ğŸ“‹ Checklist d'ImplÃ©mentation

- [ ] **Infrastructure** : Docker, PostgreSQL, Redis
- [ ] **SchÃ©mas Prisma** : Control + Tenant
- [ ] **Control API** : Gestion tenants + Provisioning
- [ ] **App API** : Middleware rÃ©solution + Factory connexions
- [ ] **SÃ©curitÃ©** : Validation slugs + Exceptions
- [ ] **Performance** : Pool connexions + Cache + Health checks
- [ ] **Monitoring** : MÃ©triques + Logs + Alertes

Cette architecture garantit une **isolation complÃ¨te**, une **scalabilitÃ© horizontale** et une **sÃ©curitÃ© robuste** pour votre SaaS multi-tenant. ğŸ¯
